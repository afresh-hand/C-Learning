# Chapter 4

## 数组
一种数据结构，能储存多个同类型的值

**创建数组的三个要素：**
1. 元素的类型
2. 数组名字
3. 数组中的元素个数

- 声明： ` typeName arrayName[arraySize]`
arraysize必须是整形常数，需要在编译时已知，不能时变量（经过尝试，可以是变量，只要在运行到声明前定义好就行了）（后面可以用new来避开这中限制）

- **超出长度的部分依然会返回值且不报错，但是返回的值时无意义的**， 编译器不会检查下标的合法性

- 初始化：可以用列表初始化的方式 `{1,2,2,3,4,5}`，好处是比较严格，可省略=号，拒绝窄缩
没有初始化的列表，其值时不稳定的，取决于之前存放在这个内存中的值
1. 只有在声明数组的时候才能初始化，后面就不行了
2. 可以提供少于数组长足的元素，其余的自动补全位0
3. 若声明时 arraySize没有提供，编译器会自己计算初始化数值的长度，并将其赋予这个数组

## 字符串

### C风格字符串
char数组保存，每个元素是一个符号，在字符串的最后用一个空字符 `\0` 来表示字符的结尾，空字符也占据数组一位
cout之类的函数都是逐个处理字符直到遇到空字符

- 初始化：用一个双引号括起来字符串就可以，编译器会自动添加空字符
编译器会隐式的将其他元素补全为空字符  
若不设置空字符 在输出的时候，程序会额外输出我们无法控制的内容直到遇到空字符
- 单引号和双引号的区别：  
单引号：表示一个字符常量  
双引号：表示一个字符+空字符，且一般这也不是一个常量，而是一个内存地址
- strlen()来确认字符串的长度--也是计算到空字符的长度（但不包含空字符
- 输入：cin--以空格或者换行符或制表符来确认输入的结束，所以当输入一个含有空格的名字时，会造成问题（**cin也将换行符保留在序列中**）
所以使用  
cin.getline(arrayName, size)：回车认为输入结束，自动删除换行符
cin.get(arrayName, size)： 保留换行符在序列中，需要连续使用两次来读掉换行符，有利于检查错误，若后一个get得到的时换行符则读取正确，否则读到的时无用的东西  

### String类
需要头文件 `<string>`，且string类包含在std命名空间下  
可以将string 变量声明为简单变量 如`string a = "happy birthday"`

- 初始化：
初始化时，string创建一个长度为0的对象，会根据收到的变量动态的调整对象的长度  
string接受其他编码方式 u""(char16_t), U""(char32_t)，但是其他编码方式的字符集无法被直接cout输出，需要额外的转换

- 赋值和拼接： 可以直接将一个string变量赋给另一个string变量而数组不行  
直接是使用 + 拼接，而数组需要strcpy(),strcat() 这俩个函数都是将后者赋值给前者 **而且这两个函数不检查带传入数组的大小，可能造成溢出的问题（使用strncat()和strncpy()来避免越界的问题）**


**c语言函数，提供方法，等待需要被执行的对象**  
**c++函数，针对对象定义对应的方法，方法只针对对应的对象，其他的对象无法使用**

- 输入：使用函数`getline(cin, stringName)`  
是string类的一个友元函数

- 原始字符串 raw string 使用R来标记 R"( .... )" 若原字符串中包含（）括号，则需要使用 R"+*(    )+*"来标记


## 结构 Strcuture 
将多种类型的数据保存在一个单元里 --用户定义的新类型， C++ OPP的基石
比；数组更加灵活的数据结构

- 定义 
1. 定义结构描述：描述并标记能够储存在结构中的数据类型 
2. 按照描述创建结构变量：和声明简单变量的方式一样 `structName variableName;`
3. 访问结构变量: 
(1) 成员运算符 `.`：`variableName.membervariableName`
(2) 箭头成员运算符 `->` ： `pointer->membervariableName`
4. 初始化方式：使用列表初始化的方式：用逗号按顺序隔开初始化的值，并用花括号将他们括起来（若大括号内未包含任何东西，则各个成员都被设置为0（char类型的的被设置为空字符），且不允许窄缩）  
**结构名不被认为是指针，不能用structName[0]的方式去访问**
5. 可以声明没有名称的结构，这样以后也无法创建这类型的结构
6. 结构中的位字段：可以指定占用特定位数的结构成员

## 共用体
Union，能够储存不同类型的数据类型，但只能存储其中一个类型  
其定义与结构定义相似。 
- 一次只能定义一个值
- 长度是最大成员的长度
-匿名共用体：anonymous union 其成员将成为位于相同地址变量。当其放在结构体中，共用体成员被认为是结构的成员直接访问

## 枚举
enum提供了一种定义符号常量的方法，可以代替const  
- 声明：
`enum spectrum {red, orange, yellow, blue, violet, indigo, ultraviolet}`  
内部的符号常量对应整数值 0-7，被称为枚举常量  
也可以显示的制定整数值来覆盖默认值

- 运算： 只定义了赋值运算（但对于有的实现可以进行加法运算）  
可以作为运算的参数被提升为整形
- 不能将一个整形赋给一个枚举类型，可以使用强制类型转换 `spectrum(2)`
- 可以随意的给枚举类型中的变量赋值，未定义的项被认为是前一项的值+1
- 取值范围：
上界是最靠近枚举类型中的最大值的2的几次幂-1
下界是 0， 或者与寻找上界的方式一样


## 指针和自由储存空间
&地址运算符， 地址一般使用十六位进制表示
*运算符 indirect value  
- 声明和初始化指针  
指针声明必须指定指针指向的数据的类型`int * a`其中间隔的空格都可以省略  
`int * p1, p2`定义的是一个指针和一个int型的比变量  
**一定要在对指针使用解除引用运算符前 将指针初始化成一个确定的适当的地址**  
不能将一个十六进制的值直接赋给一个指针，要用强制类型转换 int*  

- 使用new分配内存：  
new可以将一段未被分配的内存分配一个变量 `int * pn = new int` 这个将返回分配的内存的地址，此时只能通过指针来访问这个变量  
由于指针指向的是地址开始的地方，还指定变量的类型来确定需要分配的内存的结尾位置  
（通常new分配的内存块（堆heap或者自由存储区free store）与常规变量声明（栈stack）分配的内存块不同）  


- 使用delete来释放内存   
只能用delete释放使用new分配的内存，对空指针使用delete时安全的，不要重复释放已释放的内存块  
一定要配套的使用new和delete，否则会造成内存泄漏

- 使用new创建动态数组  
1. `int * a = new int[listSize]` 需要指定数组的元素类型和长度  
使用`delete []a` 释放内存  
**需要自己跟踪数组长度，不能使用sizeof运算符来确定数组长度（sizeof（pointerName）返回的是指针的大小，一般是4）**
2. 使用动态数组，可以指针当作数组名来时用，使用pointerName[1]来访问数组元素  
**c++中将数组名理解为指针，不同在于不能修改数组名（如进行加减运算，数组的名字被认为是指向数组第一个元素的地址**

- 指针运算  
指针量加1其增加的量等于它指向类型的字节数
`arrayName[i] = *(arrayName + i)`  
**数组的名字被认为是的一个元素的地址，当对数组名使用取地址符时，得到的是整个数组的地址**  
`short tell[10];` tell是一个 short * [10]，指向数组第一个元素的指针，tell+1 加一个short的长度  
&tell时一个指向一整个数组，&tell+1 加一个short[10]的数组的长度，一般是2\*10\*8   
short (*pa) [10] = &tell 

- 指针和字符串：字符串也被认为是一个地址，cout函数接受一个地址，按顺序访问字符串数组，直到读到空字符串  
用双引号括起来的字符串像数组名一样，也是第一个元素的地址  
当将一个字符指针指向一个字符数组时， 讲输入直接读入这个值针指向的地址可能会造成作错误：
1. 有的编译器将字符串的字面值当作只读常量，对其进行修改会造成错误
2. 有些编译器只将字符串的一个副本表示当前用的字符串，对其进行修改可能会影响其他使用这个产量常量的变量的值

- 给cout提供一个地址他将打印地址，但如果提供一个字符数组的地址，他将打印这个字符数组，如想打印这个地址，需要对他进行强制类型转换 int*()


- 使用new创建动态结构：由于生的结构没有名字只能使用指针来访问，使用箭头成员运算符(->)或者先取间接值(*ps).membervaraible

- 实例：当要读如大量字符串时，可以先将其读如一个大型数组中，然后在根据输入的长度来new对应长度的内存保存这个数据

- 自动存储， 静态存储， 动态存储  
自动存储：函数内部定义的常规变量，属于局部变量，保存与栈中，先入后出，后进先出LIFO  
动态存储：new和delete 管理了一个内存池，被称为自由存储空间或堆。可以在一个函数中分配内存在另一个函数中释放它。自动添加和删除机制让占用的内存总是连续的，但new和delete的相互影响导致占有自由存储区不是连续的  
静态存储：在整个程序执行期间都存在的存储方式。两种方式定义这种变量
（1）使用static关键词
（2）在函数外面定义它